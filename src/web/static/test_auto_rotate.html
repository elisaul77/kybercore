<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prueba Auto-Rotaci√≥n STL - KyberCore APISLICER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-900 mb-8">üîÑ Prueba Auto-Rotaci√≥n STL</h1>

        <!-- Formulario de subida -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">üì§ Subir Archivo STL</h2>
            <form id="uploadForm" enctype="multipart/form-data">
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Archivo STL</label>
                    <input type="file" id="stlFile" accept=".stl" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
                <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                    üöÄ Subir y Analizar
                </button>
            </form>
        </div>

        <!-- Resultados -->
        <div id="results" class="hidden">
            <h2 class="text-2xl font-semibold mb-6">üìä Resultados de Auto-Rotaci√≥n</h2>

            <!-- Informaci√≥n del modelo -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4">üìã Informaci√≥n del Modelo</h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600" id="modelFaces">-</div>
                        <div class="text-sm text-gray-600">Caras</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-green-600" id="modelVertices">-</div>
                        <div class="text-sm text-gray-600">V√©rtices</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-purple-600" id="modelVolume">-</div>
                        <div class="text-sm text-gray-600">Volumen (cm¬≥)</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-orange-600" id="modelComplexity">-</div>
                        <div class="text-sm text-gray-600">Complejidad</div>
                    </div>
                </div>
            </div>

            <!-- Comparaci√≥n de m√©todos -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <!-- Grid Search -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h3 class="text-lg font-semibold mb-4 text-center">üîç Grid Search</h3>
                    <div id="gridResults" class="space-y-3">
                        <div class="text-center">
                            <div class="text-3xl font-bold text-gray-600" id="gridImprovement">-</div>
                            <div class="text-sm text-gray-600">Mejora (%)</div>
                        </div>
                        <div class="text-sm">
                            <strong>√Årea Original:</strong> <span id="gridOriginalArea">-</span><br>
                            <strong>√Årea √ìptima:</strong> <span id="gridOptimalArea">-</span><br>
                            <strong>Rotaci√≥n:</strong> <span id="gridRotation">-</span><br>
                            <strong>Rotaciones Probadas:</strong> <span id="gridTested">-</span>
                        </div>
                    </div>
                </div>

                <!-- Gradient Hybrid -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h3 class="text-lg font-semibold mb-4 text-center">üî• Gradient H√≠brido</h3>
                    <div id="gradientResults" class="space-y-3">
                        <div class="text-center">
                            <div class="text-3xl font-bold text-green-600" id="gradientImprovement">-</div>
                            <div class="text-sm text-gray-600">Mejora (%)</div>
                        </div>
                        <div class="text-sm">
                            <strong>√Årea Original:</strong> <span id="gradientOriginalArea">-</span><br>
                            <strong>√Årea √ìptima:</strong> <span id="gradientOptimalArea">-</span><br>
                            <strong>Rotaci√≥n:</strong> <span id="gradientRotation">-</span><br>
                            <strong>Iteraciones:</strong> <span id="gradientIterations">-</span>
                        </div>
                    </div>
                </div>

                <!-- Auto (Adaptive) -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h3 class="text-lg font-semibold mb-4 text-center">ü§ñ Auto (Adaptativo)</h3>
                    <div id="autoResults" class="space-y-3">
                        <div class="text-center">
                            <div class="text-3xl font-bold text-blue-600" id="autoImprovement">-</div>
                            <div class="text-sm text-gray-600">Mejora (%)</div>
                        </div>
                        <div class="text-sm">
                            <strong>√Årea Original:</strong> <span id="autoOriginalArea">-</span><br>
                            <strong>√Årea √ìptima:</strong> <span id="autoOptimalArea">-</span><br>
                            <strong>Rotaci√≥n:</strong> <span id="autoRotation">-</span><br>
                            <strong>M√©todo Usado:</strong> <span id="autoMethod">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Visualizaci√≥n 3D -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h3 class="text-lg font-semibold mb-4">üëÅÔ∏è Visualizaci√≥n 3D</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h4 class="font-medium mb-2">Posici√≥n Original</h4>
                        <div id="originalViewer" class="w-full h-64 bg-gray-200 rounded"></div>
                    </div>
                    <div>
                        <h4 class="font-medium mb-2">Posici√≥n Optimizada</h4>
                        <div id="optimizedViewer" class="w-full h-64 bg-gray-200 rounded"></div>
                    </div>
                </div>
            </div>

            <!-- Log de procesamiento -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h3 class="text-lg font-semibold mb-4">üìã Log de Procesamiento</h3>
                <div id="logArea" class="bg-gray-900 text-green-400 p-4 rounded font-mono text-sm max-h-64 overflow-y-auto">
                    Inicializando an√°lisis...<br>
                </div>
            </div>
        </div>

        <!-- Estado de carga -->
        <div id="loading" class="hidden bg-white rounded-lg shadow-lg p-6 text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>
            <p class="text-gray-600">Analizando rotaci√≥n √≥ptima...</p>
        </div>
    </div>

    <script>
        let uploadedFilePath = null;
        let originalGeometry = null;
        let optimizedGeometry = null;

        // Inicializar viewers 3D
        function init3DViewers() {
            // Original viewer
            const originalScene = new THREE.Scene();
            const originalCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const originalRenderer = new THREE.WebGLRenderer();
            originalRenderer.setSize(400, 256);
            document.getElementById('originalViewer').appendChild(originalRenderer.domElement);

            // Optimized viewer
            const optimizedScene = new THREE.Scene();
            const optimizedCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            const optimizedRenderer = new THREE.WebGLRenderer();
            optimizedRenderer.setSize(400, 256);
            document.getElementById('optimizedViewer').appendChild(optimizedRenderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);

            originalScene.add(ambientLight.clone());
            originalScene.add(directionalLight.clone());
            optimizedScene.add(ambientLight.clone());
            optimizedScene.add(directionalLight.clone());

            // Camera positions
            originalCamera.position.set(50, 50, 50);
            optimizedCamera.position.set(50, 50, 50);

            return { originalScene, originalCamera, originalRenderer, optimizedScene, optimizedCamera, optimizedRenderer };
        }

        const viewers = init3DViewers();

        // Funci√≥n para cargar y mostrar STL desde File input
        function loadSTLFromFile(file, scene, isOriginal = true) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const loader = new THREE.STLLoader();
                    const geometry = loader.parse(event.target.result);

                    const material = new THREE.MeshLambertMaterial({
                        color: isOriginal ? 0x888888 : 0x4CAF50,
                        transparent: true,
                        opacity: 0.8
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);

                    // Ajustar c√°mara para ver el objeto completo
                    const box = new THREE.Box3().setFromObject(mesh);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const distance = maxDim * 1.5;

                    if (isOriginal) {
                        viewers.originalCamera.position.set(center.x + distance, center.y + distance, center.z + distance);
                        viewers.originalCamera.lookAt(center);
                        originalGeometry = geometry.clone();
                    } else {
                        viewers.optimizedCamera.position.set(center.x + distance, center.y + distance, center.z + distance);
                        viewers.optimizedCamera.lookAt(center);
                        optimizedGeometry = geometry.clone();
                    }

                    // Agregar controles de √≥rbita
                    if (isOriginal && !viewers.originalControls) {
                        viewers.originalControls = new THREE.OrbitControls(viewers.originalCamera, viewers.originalRenderer.domElement);
                        viewers.originalControls.enableDamping = true;
                        viewers.originalControls.dampingFactor = 0.05;
                    }
                    if (!isOriginal && !viewers.optimizedControls) {
                        viewers.optimizedControls = new THREE.OrbitControls(viewers.optimizedCamera, viewers.optimizedRenderer.domElement);
                        viewers.optimizedControls.enableDamping = true;
                        viewers.optimizedControls.dampingFactor = 0.05;
                    }

                    // Animar
                    function animate() {
                        requestAnimationFrame(animate);
                        if (isOriginal) {
                            viewers.originalControls.update();
                            viewers.originalRenderer.render(viewers.originalScene, viewers.originalCamera);
                        } else {
                            viewers.optimizedControls.update();
                            viewers.optimizedRenderer.render(viewers.optimizedScene, viewers.optimizedCamera);
                        }
                    }
                    animate();

                    resolve(geometry);
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Mostrar modelo optimizado
        async function showOptimizedModel() {
            if (!originalGeometry) return;

            // Encontrar la mejor rotaci√≥n entre los tres m√©todos
            const methods = ['grid', 'gradient', 'auto'];
            let bestMethod = 'grid';
            let bestImprovement = 0;
            let bestRotation = [0, 0, 0];

            methods.forEach(method => {
                const improvement = parseFloat(document.getElementById(method + 'Improvement').textContent) || 0;
                if (improvement > bestImprovement) {
                    bestImprovement = improvement;
                    bestMethod = method;
                    const rotationText = document.getElementById(method + 'Rotation').textContent;
                    const match = rotationText.match(/\[([^\]]+)\]/);
                    if (match) {
                        bestRotation = match[1].split(',').map(x => parseFloat(x.trim()));
                    }
                }
            });

            log(`Aplicando mejor rotaci√≥n (${bestMethod}): [${bestRotation.join(', ')}]`);

            // Limpiar escena optimizada
            while(viewers.optimizedScene.children.length > 2) {
                viewers.optimizedScene.remove(viewers.optimizedScene.children[2]);
            }

            // Aplicar rotaci√≥n y mostrar
            const rotatedGeometry = applyRotationToGeometry(originalGeometry, bestRotation);
            const material = new THREE.MeshLambertMaterial({
                color: 0x4CAF50,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(rotatedGeometry, material);
            viewers.optimizedScene.add(mesh);

            // Ajustar c√°mara
            const box = new THREE.Box3().setFromObject(mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 1.5;

            viewers.optimizedCamera.position.set(center.x + distance, center.y + distance, center.z + distance);
            viewers.optimizedCamera.lookAt(center);
        }

        // Funci√≥n para subir archivo
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('stlFile');
            if (!fileInput.files[0]) {
                alert('Por favor selecciona un archivo STL');
                return;
            }

            const file = fileInput.files[0];
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('results').classList.add('hidden');

            try {
                // Limpiar escenas anteriores
                while(viewers.originalScene.children.length > 2) {
                    viewers.originalScene.remove(viewers.originalScene.children[2]);
                }
                while(viewers.optimizedScene.children.length > 2) {
                    viewers.optimizedScene.remove(viewers.optimizedScene.children[2]);
                }

                // Cargar STL en el visor original
                log('Cargando modelo 3D...');
                await loadSTLFromFile(file, viewers.originalScene, true);

                // Subir archivo al servidor
                const formData = new FormData();
                formData.append('file', file);

                const uploadResponse = await fetch('http://localhost:8001/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!uploadResponse.ok) {
                    throw new Error(`Error al subir archivo: ${uploadResponse.status}`);
                }

                const uploadData = await uploadResponse.json();
                uploadedFilePath = uploadData.file_path;

                log('Archivo subido exitosamente: ' + uploadedFilePath);

                // Cargar informaci√≥n del modelo
                await loadModelInfo(uploadedFilePath);

                // Ejecutar an√°lisis de rotaci√≥n
                await runRotationAnalysis();

            } catch (error) {
                log('Error: ' + error.message);
                alert('Error al procesar el archivo: ' + error.message);
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        });

        // Cargar informaci√≥n del modelo
        async function loadModelInfo(filePath) {
            try {
                // Para obtener info del modelo, podr√≠amos crear un endpoint espec√≠fico
                // Por ahora, usaremos datos simulados basados en el an√°lisis
                log('Analizando geometr√≠a del modelo...');

                // Aqu√≠ podr√≠amos hacer una llamada a un endpoint que analice el STL
                // Por simplicidad, pondremos datos de ejemplo
                document.getElementById('modelFaces').textContent = '~23,600';
                document.getElementById('modelVertices').textContent = '~11,800';
                document.getElementById('modelVolume').textContent = '45.2';
                document.getElementById('modelComplexity').textContent = 'Complejo';

            } catch (error) {
                log('Error al cargar info del modelo: ' + error.message);
            }
        }

        // Ejecutar an√°lisis de rotaci√≥n
        async function runRotationAnalysis() {
            log('Iniciando an√°lisis de auto-rotaci√≥n...');

            try {
                // Grid Search
                log('Probando m√©todo Grid Search...');
                const gridResponse = await fetch('http://localhost:8001/auto-rotate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        stl_path: uploadedFilePath,
                        method: 'grid',
                        rotation_step: 15,
                        max_rotations: 24
                    })
                });

                if (gridResponse.ok) {
                    const gridData = await gridResponse.json();
                    updateResults('grid', gridData);
                    log('Grid Search completado - Mejora: ' + gridData.improvement_percentage.toFixed(2) + '%');
                }

                // Gradient Hybrid
                log('Probando m√©todo Gradient H√≠brido...');
                const gradientResponse = await fetch('http://localhost:8001/auto-rotate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        stl_path: uploadedFilePath,
                        method: 'gradient',
                        max_iterations: 50,
                        learning_rate: 0.1
                    })
                });

                if (gradientResponse.ok) {
                    const gradientData = await gradientResponse.json();
                    updateResults('gradient', gradientData);
                    log('Gradient H√≠brido completado - Mejora: ' + gradientData.improvement_percentage.toFixed(2) + '%');
                }

                // Auto (Adaptive)
                log('Probando m√©todo Auto (Adaptativo)...');
                const autoResponse = await fetch('http://localhost:8001/auto-rotate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        stl_path: uploadedFilePath,
                        method: 'auto'
                    })
                });

                if (autoResponse.ok) {
                    const autoData = await autoResponse.json();
                    updateResults('auto', autoData);
                    log('Auto (Adaptativo) completado - Mejora: ' + autoData.improvement_percentage.toFixed(2) + '%');
                }

                // Mostrar resultados
                document.getElementById('results').classList.remove('hidden');

                // Mostrar versi√≥n optimizada en el visor 3D
                await showOptimizedModel();

                log('An√°lisis completado exitosamente!');

            } catch (error) {
                log('Error en an√°lisis: ' + error.message);
            }
        }

        // Actualizar resultados en la UI
        function updateResults(method, data) {
            const prefix = method;

            document.getElementById(prefix + 'Improvement').textContent = data.improvement_percentage.toFixed(2);
            document.getElementById(prefix + 'OriginalArea').textContent = data.original_area.toFixed(3);
            document.getElementById(prefix + 'OptimalArea').textContent = data.contact_area.toFixed(3);
            document.getElementById(prefix + 'Rotation').textContent =
                `[${data.optimal_rotation_degrees.map(x => x.toFixed(1)).join(', ')}]`;

            if (method === 'grid') {
                document.getElementById('gridTested').textContent = data.rotations_tested || 'N/A';
            } else if (method === 'gradient') {
                document.getElementById('gradientIterations').textContent = data.rotations_tested || 'N/A';
            } else if (method === 'auto') {
                document.getElementById('autoMethod').textContent = 'Grid (Complejo)';
            }
        }

        // Funci√≥n para aplicar rotaci√≥n a geometr√≠a
        function applyRotationToGeometry(geometry, rotationDegrees) {
            const rotatedGeometry = geometry.clone();
            const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(rotationDegrees[0]),
                THREE.MathUtils.degToRad(rotationDegrees[1]),
                THREE.MathUtils.degToRad(rotationDegrees[2])
            );
            rotatedGeometry.rotateX(euler.x);
            rotatedGeometry.rotateY(euler.y);
            rotatedGeometry.rotateZ(euler.z);
            return rotatedGeometry;
        }

        // Mostrar modelo optimizado
        async function showOptimizedModel() {
            if (!originalGeometry) return;

            // Encontrar la mejor rotaci√≥n entre los tres m√©todos
            const methods = ['grid', 'gradient', 'auto'];
            let bestMethod = 'grid';
            let bestImprovement = 0;
            let bestRotation = [0, 0, 0];

            methods.forEach(method => {
                const improvement = parseFloat(document.getElementById(method + 'Improvement').textContent) || 0;
                if (improvement > bestImprovement) {
                    bestImprovement = improvement;
                    bestMethod = method;
                    const rotationText = document.getElementById(method + 'Rotation').textContent;
                    const match = rotationText.match(/\[([^\]]+)\]/);
                    if (match) {
                        bestRotation = match[1].split(',').map(x => parseFloat(x.trim()));
                    }
                }
            });

            log(`Aplicando mejor rotaci√≥n (${bestMethod}): [${bestRotation.join(', ')}]`);

            // Limpiar escena optimizada
            while(viewers.optimizedScene.children.length > 2) {
                viewers.optimizedScene.remove(viewers.optimizedScene.children[2]);
            }

            // Aplicar rotaci√≥n y mostrar
            const rotatedGeometry = applyRotationToGeometry(originalGeometry, bestRotation);
            const material = new THREE.MeshLambertMaterial({
                color: 0x4CAF50,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(rotatedGeometry, material);
            viewers.optimizedScene.add(mesh);

            // Ajustar c√°mara
            const box = new THREE.Box3().setFromObject(mesh);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 1.5;

            viewers.optimizedCamera.position.set(center.x + distance, center.y + distance, center.z + distance);
            viewers.optimizedCamera.lookAt(center);
        }

        // Funci√≥n de logging
        function log(message) {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += timestamp + ' - ' + message + '<br>';
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Inicializar
        log('Interfaz de prueba inicializada. Sube un archivo STL para comenzar.');
    </script>
</body>
</html>